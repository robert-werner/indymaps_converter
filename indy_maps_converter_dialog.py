# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IndyMapsConverterDialog
                                 A QGIS plugin
 This plugin imports/exports the QGIS project to the IndyMaps format (*.imx)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonid Kolesnichenko
        email                : xperience439@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.QtCore import QMetaType
from PyQt5.QtGui import QColor
from cbor2 import load
from cloudinit import settings
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.core import QgsProject, QgsLayerTreeGroup, QgsLayerTreeLayer, Qgis, QgsField, QgsCoordinateReferenceSystem, QgsRectangle, QgsReferencedRectangle, QgsPointXY, QgsGeometry, QgsFields, QgsVectorLayer, QgsFeature
from qgis.utils import iface

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'indy_maps_converter_dialog_base.ui'))


class IndyMapsConverterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(IndyMapsConverterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.importButton.clicked.connect(self.import_imx)
        self.exportButton.clicked.connect(self.export_imx)

        self.canvas = iface.mapCanvas()
        self.iface = iface

    def import_imx(self):
        self.importButton.setEnabled(False)
        imx_path = self.inputFileQgsWidget.filePath()

        self.importProgressBar.setValue(0)

        project = QgsProject.instance()
        crs = QgsCoordinateReferenceSystem('EPSG:4326')


        with open(imx_path, 'rb') as fp:
            obj = load(fp)
            border = obj['borders'][0]
            classes = obj['classes']
            settings = obj['settings']

            xs = [pt[1] / settings['from-degs-mul'] for pt in border]
            ys = [pt[0] / settings['from-degs-mul'] for pt in border]

            # Compute min and max for x and y
            xmin, xmax = min(xs), max(xs)
            ymin, ymax = min(ys), max(ys)

            rectangle = QgsRectangle(xmin, ymin, xmax, ymax)

            referenced_extent = QgsReferencedRectangle(rectangle, crs)

            project.viewSettings().setPresetFullExtent(referenced_extent)

            self.canvas.refresh()

            layers_to_add = {}

            for cls in classes:
                self.importProgressLabel.setText(f"Preprocessing layer: {cls['id']}")
                if cls['shape'] == 1: # Then it is point
                    layer_name = cls['id']
                    layer_order = cls['layer']
                    layer = QgsVectorLayer("Point?crs=EPSG:4326",
                                           layer_name,
                                           "memory")
                    symbol = layer.renderer().symbol()
                    symbol.setSizeUnit(Qgis.RenderUnit.Millimeters)  # switch to millimeters
                    rgba_fill_color = (cls['fill-color'] >> 16) & 0xff, (cls['fill-color'] >> 8) & 0xff, (cls['fill-color']) & 0xff, (cls['fill-color'] >> 24) & 0xff
                    symbol.setColor(QColor.fromRgb(*rgba_fill_color))
                    symbol.setSize(cls['width'])
                    for obj in cls['objects']:
                        outer_geom = obj[0][0][0]
                        attribs = obj[-1] # TODO: fix when correct imx will be sent


                        qgs_point = QgsPointXY(outer_geom[1] / settings['from-degs-mul'],
                                               outer_geom[0] /settings['from-degs-mul'])
                        outer_qgs_geometry = QgsGeometry.fromPointXY(qgs_point)

                        outer_feature = self._attribute_feature(attribs, layer)

                        outer_feature.setGeometry(outer_qgs_geometry)

                        layer.dataProvider().addFeature(outer_feature)

                    layers_to_add[layer_order] = layer
                if cls['shape'] == 2: # Then it is line
                    layer_name = cls['id']
                    layer_order = cls['layer']
                    layer = QgsVectorLayer("LineString?crs=EPSG:4326",
                                           layer_name,
                                           "memory")
                    symbol = layer.renderer().symbol()
                    symbol.setWidthUnit(Qgis.RenderUnit.Millimeters)  # switch to millimeters
                    rgba_fill_color = (cls['line-color'] >> 16) & 0xff, (cls['line-color'] >> 8) & 0xff, (cls['line-color']) & 0xff, (cls['line-color'] >> 24) & 0xff
                    symbol.setColor(QColor.fromRgb(*rgba_fill_color))
                    symbol.setWidth(cls['width'])

                    for obj in cls['objects']:
                        attribs = obj[-1]
                        outer_geometry = []
                        outer_geom = obj[0]
                        outer_starting_point = outer_geom[0][0]
                        for x, y in outer_geom[0][1:]:
                            x = (outer_starting_point[0] + x) / settings['from-degs-mul']
                            y = (outer_starting_point[1] + y) / settings['from-degs-mul']
                            outer_geometry.append(QgsPointXY(y, x))

                        outer_qgs_geometry = QgsGeometry.fromPolylineXY(outer_geometry)

                        outer_feature = self._attribute_feature(attribs, layer)

                        outer_feature.setGeometry(outer_qgs_geometry)

                        layer.dataProvider().addFeature(outer_feature)

                    layers_to_add[layer_order] = layer
                if cls['shape'] == 3: # Then it is multipolygon
                    layer_name = cls['id']
                    layer_order = cls['layer']
                    layer = QgsVectorLayer("Polygon?crs=EPSG:4326",
                                           layer_name,
                                           "memory")
                    symbol = layer.renderer().symbol()
                    rgba_fill_color = (cls['fill-color'] >> 16) & 0xff, (cls['fill-color'] >> 8) & 0xff, (cls['fill-color']) & 0xff, (cls['fill-color'] >> 24) & 0xff
                    rgba_stroke_color = (cls['line-color'] >> 16) & 0xff, (cls['line-color'] >> 8) & 0xff, (cls['line-color']) & 0xff, (cls['line-color'] >> 24) & 0xff
                    symbol.setColor(QColor.fromRgb(*rgba_fill_color))  # Fill color
                    symbol.symbolLayer(0).setStrokeWidth(cls['width'])  # in millimeters
                    symbol.symbolLayer(0).setStrokeColor(QColor.fromRgb(*rgba_stroke_color))

                    for obj in cls['objects']:
                        attribs = obj[-1]
                        outer_geometry = self.create_polygon(obj, settings)

                        outer_feature = self._attribute_feature(attribs, layer)

                        outer_feature.setGeometry(outer_geometry)

                        layer.dataProvider().addFeature(outer_feature)

                    layers_to_add[layer_order] = layer

        sorted_layers = dict(sorted(layers_to_add.items()))

        for layer in sorted_layers.values():
            self.importProgressBar.setValue(self.importProgressBar.value() + (100 // len(sorted_layers)))
            QgsProject.instance().addMapLayer(layer)
            self.canvas.refresh()

        self.importProgressBar.setValue(100)
        self.importButton.setEnabled(True)

    def create_polygon(self, obj, settings, inner=False):
        if inner:
            idx = 1
            if not obj[1]:
                return QgsGeometry.fromWkt("POLYGON EMPTY")
        else:
            idx = 0

        points = []
        geom = obj[idx]
        outer_starting_point = geom[idx][0]
        points.append(QgsPointXY(outer_starting_point[1] / settings['from-degs-mul'],
                                       outer_starting_point[0] / settings['from-degs-mul']))
        for x, y in geom[idx][1:]:
            x = (outer_starting_point[0] + x) / settings['from-degs-mul']
            y = (outer_starting_point[1] + y) / settings['from-degs-mul']
            points.append(QgsPointXY(y, x))

        return QgsGeometry.fromPolygonXY([points])

    def _attribute_feature(self, attributes, layer):
        for attribute in attributes.items():
            layer.dataProvider().addAttributes([
                QgsField(attribute[0], QMetaType.Type.QString)
            ])
        layer.updateFields()
        feature = QgsFeature(layer.fields())
        attr_list = [attributes.get(field.name()) for field in layer.fields()]
        feature.setAttributes(attr_list)
        return feature

    def get_vector_layers_in_order(self, node):
        layers = []
        for child in node.children():
            if isinstance(child, QgsLayerTreeLayer):
                layer = child.layer()
                if isinstance(layer, QgsVectorLayer):
                    layers.append(layer)
            elif isinstance(child, QgsLayerTreeGroup):
                layers.extend(self.get_vector_layers_in_order(child))
        return layers

    def export_imx(self):
        obj = {}
        obj['settings'] = {}
        obj['settings']['from-degs-mul'] = 10000000.0
        obj['settings']['compression-policy'] = 1
        obj['settings']['min-mip'] = 0.0
        obj['settings']['max-mip'] = 50.0
        self.exportButton.setEnabled(False)
        # Access the current QGIS project instance
        project = QgsProject.instance()

        vector_layers = self.get_vector_layers_in_order(project.layerTreeRoot())

        preset_extent = project.viewSettings().presetFullExtent()

        if not preset_extent.isNull():
            xmin = preset_extent.xMinimum()
            ymin = preset_extent.yMinimum()
            xmax = preset_extent.xMaximum()
            ymax = preset_extent.yMaximum()

            # Optional: Print pairs to verify
            print(f"Bottom-left (xmin, ymin): ({ymin}, {xmin})")
            print(f"Top-right (xmax, ymax): ({ymax}, {xmax})")

            obj['borders'] = [
                [ymin * obj['settings']['from-degs-mul'], xmin * obj['settings']['from-degs-mul']],
                [0, 0],
                [ymax * obj['settings']['from-degs-mul'], xmax * obj['settings']['from-degs-mul']],
                [ymax * obj['settings']['from-degs-mul'], xmax * obj['settings']['from-degs-mul']],
            ]

        imx_path = self.exportFileQgsWidget.filePath()

        self.exportButton.setEnabled(True)