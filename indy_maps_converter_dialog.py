# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IndyMapsConverterDialog
                                 A QGIS plugin
 This plugin imports/exports the QGIS project to the IndyMaps format (*.imx)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonid Kolesnichenko
        email                : xperience439@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from datetime import datetime

from PyQt5.QtCore import QMetaType
from PyQt5.QtGui import QColor
from cbor2 import load, dump
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.core import (
    QgsProject, QgsWkbTypes, QgsLayerTreeGroup, QgsLayerTreeLayer,
    Qgis, QgsField, QgsCoordinateReferenceSystem, QgsRectangle,
    QgsReferencedRectangle, QgsPointXY, QgsGeometry, QgsVectorLayer,
    QgsFeature
)
from qgis.utils import iface

# Константы для типов геометрии
POINT_TYPE = 1
LINE_TYPE = 2
POLYGON_TYPE = 3

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'indy_maps_converter_dialog_base.ui'))


class IndyMapsConverterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super().__init__(parent)
        self.setupUi(self)

        self.importButton.clicked.connect(self.import_imx)
        self.exportButton.clicked.connect(self.export_imx)
        self.from_degs_mul = 10000000.0

        self.canvas = iface.mapCanvas()
        self.iface = iface

    def custom_encoder(self, encoder, value):
        """Custom encoder for unsupported types"""
        if isinstance(value, set):
            encoder.encode(list(value))
        elif isinstance(value, datetime):
            encoder.encode(value.isoformat())
        elif hasattr(value, '__dict__'):
            encoder.encode(value.__dict__)
        else:
            encoder.encode(str(value))

    def _decode_rgba(self, color_int):
        """Декодирование RGBA из целого числа"""
        return (
            (color_int >> 16) & 0xff,
            (color_int >> 8) & 0xff,
            color_int & 0xff,
            (color_int >> 24) & 0xff
        )

    def _process_borders(self, obj, crs):
        """Обработка границ проекта"""
        border = obj['borders'][0]
        settings = obj['settings']

        xs = [pt[1] / settings['from-degs-mul'] for pt in border]
        ys = [pt[0] / settings['from-degs-mul'] for pt in border]

        rectangle = QgsRectangle(min(xs), min(ys), max(xs), max(ys))
        referenced_extent = QgsReferencedRectangle(rectangle, crs)

        QgsProject.instance().viewSettings().setPresetFullExtent(referenced_extent)
        self.canvas.refresh()

    def _create_layer(self, cls, geometry_type, settings):
        """Создание векторного слоя с настройками символа"""
        layer = QgsVectorLayer(
            f"{geometry_type}?crs=EPSG:4326",
            cls['id'],
            "memory"
        )

        symbol = layer.renderer().symbol()

        if cls['shape'] == POINT_TYPE:
            symbol.setSizeUnit(Qgis.RenderUnit.Millimeters)
            rgba = self._decode_rgba(cls['fill-color'])
            symbol.setColor(QColor.fromRgb(*rgba))
            symbol.setSize(cls['width'])
        elif cls['shape'] == LINE_TYPE:
            symbol.setWidthUnit(Qgis.RenderUnit.Millimeters)
            rgba = self._decode_rgba(cls['line-color'])
            symbol.setColor(QColor.fromRgb(*rgba))
            symbol.setWidth(cls['width'])
        elif cls['shape'] == POLYGON_TYPE:
            fill_rgba = self._decode_rgba(cls['fill-color'])
            stroke_rgba = self._decode_rgba(cls['line-color'])
            symbol.setColor(QColor.fromRgb(*fill_rgba))
            symbol.symbolLayer(0).setStrokeWidth(cls['width'])
            symbol.symbolLayer(0).setStrokeColor(QColor.fromRgb(*stroke_rgba))

        return layer

    def _process_points(self, cls, settings, all_attributes):
        """Обработка точечных объектов"""
        features = []
        for obj_data in cls['objects']:
            outer_geom = obj_data[0][0][0]
            attribs = obj_data[-1]

            all_attributes.update(attribs.keys())

            qgs_point = QgsPointXY(
                outer_geom[1] / settings['from-degs-mul'],
                outer_geom[0] / settings['from-degs-mul']
            )

            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPointXY(qgs_point))
            feature.setAttributes(list(attribs.values()))
            features.append(feature)

        return features

    def _process_lines(self, cls, settings, all_attributes):
        """Обработка линейных объектов"""
        features = []
        for obj_data in cls['objects']:
            attribs = obj_data[-1]
            all_attributes.update(attribs.keys())

            outer_geom = obj_data[0]
            outer_starting_point = outer_geom[0][0]
            outer_geometry = []

            for x, y in outer_geom[0][1:]:
                x = (outer_starting_point[0] + x) / settings['from-degs-mul']
                y = (outer_starting_point[1] + y) / settings['from-degs-mul']
                outer_geometry.append(QgsPointXY(y, x))

            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolylineXY(outer_geometry))
            feature.setAttributes(list(attribs.values()))
            features.append(feature)

        return features

    def _process_polygons(self, cls, settings, all_attributes):
        """Обработка полигональных объектов"""
        features = []
        for obj_data in cls['objects']:
            attribs = obj_data[-1]
            all_attributes.update(attribs.keys())

            outer_geometry = self._create_polygon(obj_data, settings)
            feature = QgsFeature()
            feature.setGeometry(outer_geometry)
            feature.setAttributes(list(attribs.values()))
            features.append(feature)

        return features

    def _create_polygon(self, obj, settings, inner=False):
        """Создание полигона из данных объекта"""
        idx = 1 if inner else 0

        if inner and not obj[1]:
            return QgsGeometry.fromWkt("POLYGON EMPTY")

        points = []
        geom = obj[idx]
        outer_starting_point = geom[idx][0]

        points.append(QgsPointXY(
            outer_starting_point[1] / settings['from-degs-mul'],
            outer_starting_point[0] / settings['from-degs-mul']
        ))

        for x, y in geom[idx][1:]:
            x = (outer_starting_point[0] + x) / settings['from-degs-mul']
            y = (outer_starting_point[1] + y) / settings['from-degs-mul']
            points.append(QgsPointXY(y, x))

        return QgsGeometry.fromPolygonXY([points])

    def import_imx(self):
        """Импорт IMX файла"""
        try:
            self.importButton.setEnabled(False)
            imx_path = self.inputFileQgsWidget.filePath()

            if not imx_path:
                raise ValueError("Не выбран файл для импорта")

            self.importProgressBar.setValue(0)

            with open(imx_path, 'rb') as fp:
                obj = load(fp)

            crs = QgsCoordinateReferenceSystem('EPSG:4326')
            self._process_borders(obj, crs)

            layers_to_add = {}
            total_classes = len(obj['classes'])

            for i, cls in enumerate(obj['classes']):
                self.importProgressLabel.setText(f"Обработка слоя: {cls['id']}")

                # Определяем тип геометрии
                if cls['shape'] == POINT_TYPE:
                    geometry_type = "Point"
                elif cls['shape'] == LINE_TYPE:
                    geometry_type = "LineString"
                elif cls['shape'] == POLYGON_TYPE:
                    geometry_type = "Polygon"
                else:
                    continue

                # Создаем слой
                layer = self._create_layer(cls, geometry_type, obj['settings'])
                all_attributes = set()

                # Обрабатываем объекты в зависимости от типа
                if cls['shape'] == POINT_TYPE:
                    features = self._process_points(cls, obj['settings'], all_attributes)
                elif cls['shape'] == LINE_TYPE:
                    features = self._process_lines(cls, obj['settings'], all_attributes)
                elif cls['shape'] == POLYGON_TYPE:
                    features = self._process_polygons(cls, obj['settings'], all_attributes)

                # Добавляем поля атрибутов
                if all_attributes:
                    layer.dataProvider().addAttributes([
                        QgsField(attr, QMetaType.Type.QString)
                        for attr in all_attributes
                    ])
                    layer.updateFields()
                    # Обновляем атрибуты для всех фич
                    for feature in features:
                        feature.setFields(layer.fields())

                # Добавляем объекты в слой
                if features:
                    layer.dataProvider().addFeatures(features)

                layers_to_add[cls['layer']] = layer
                self.importProgressBar.setValue(int((i + 1) / total_classes * 100))

            # Добавляем слои в проект в правильном порядке
            for layer_order in sorted(layers_to_add.keys()):
                QgsProject.instance().addMapLayer(layers_to_add[layer_order])

            self.canvas.refresh()
            self.importProgressBar.setValue(100)

        except Exception as e:
            self.iface.messageBar().pushCritical("Ошибка", f"Ошибка импорта: {str(e)}")
        finally:
            self.importButton.setEnabled(True)

    def _shape_detector(self, vector_layer):
        """Определение типа геометрии слоя"""
        geom_type = vector_layer.geometryType()
        if geom_type == QgsWkbTypes.PointGeometry:
            return POINT_TYPE
        elif geom_type == QgsWkbTypes.LineGeometry:
            return LINE_TYPE
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return POLYGON_TYPE
        return None

    def get_vector_layers_in_order(self, node):
        """Получение векторных слоев в порядке их отображения в дереве слоев"""
        layers = []
        for child in node.children():
            if isinstance(child, QgsLayerTreeLayer):
                layer = child.layer()
                if isinstance(layer, QgsVectorLayer):
                    layers.append(layer)
            elif isinstance(child, QgsLayerTreeGroup):
                layers.extend(self.get_vector_layers_in_order(child))
        return layers

    def convert_to_ims_coord_format(self, x, y):
        """Конвертация координат в формат IMS"""
        return [int(y * self.from_degs_mul), int(x * self.from_degs_mul)]

    def substract_from_first_point(self, first_point, x, y):
        """Вычитание координат из первой точки"""
        return [
            int((first_point.y() - y) * self.from_degs_mul),
            int((first_point.x() - x) * self.from_degs_mul)
        ]

    def color_converter(self, color):
        """Конвертация цвета в целочисленный формат"""
        hex_clean = color.lstrip('#')
        argb_int = int(hex_clean, 16)

        # Если hex был #RRGGBB (6 digits, no alpha), add full opacity (alpha=255)
        if len(hex_clean) == 6:
            argb_int = (255 << 24) | argb_int
        return argb_int

    @staticmethod
    def _qcolor_to_argb_int(c: QColor) -> int:
        """Конвертирует QColor в ARGB uint (alpha << 24 | red << 16 | green << 8 | blue)."""
        return (c.alpha() << 24) | (c.red() << 16) | (c.green() << 8) | c.blue()

    def export_imx(self):
        self.exportButton.setEnabled(False)
        try:
            obj = {
                'settings': {
                    'min-mip': 0.0,
                    'max-mip': 50.0,
                    'compression-policy': 1,
                    'from-degs-mul': 10_000_000.0,
                },
                'borders': [],
                'classes': []
            }
            mul = obj['settings']['from-degs-mul']

            project = QgsProject.instance()

            # Экспорт границ из presetFullExtent как один полигон
            preset_extent = project.viewSettings().presetFullExtent()
            if not preset_extent.isNull():
                xmin = preset_extent.xMinimum()
                ymin = preset_extent.yMinimum()
                xmax = preset_extent.xMaximum()
                ymax = preset_extent.yMaximum()
                # Полигон: top-left, top-right, bottom-right, bottom-left (замкнутый относительно первой точки)
                abs_first = [ymax * mul, xmin * mul]  # [lat_mul, lon_mul]
                polygon = [abs_first]
                # Delta to top-right
                polygon.append([0, (xmax - xmin) * mul])
                # Delta to bottom-right
                polygon.append([(ymin - ymax) * mul, 0])
                # Delta to bottom-left
                polygon.append([0, (xmin - xmax) * mul])
                obj['borders'] = [polygon]

            # Рекурсивный проход по дереву слоев для получения векторных слоев с parent-id
            def collect_layers(node, parent_id=""):
                collected = []
                for child in node.children():
                    if isinstance(child, QgsLayerTreeGroup):
                        group_id = child.name() if child.name() else parent_id
                        collected.extend(collect_layers(child, group_id))
                    elif isinstance(child, QgsLayerTreeLayer):
                        layer = child.layer()
                        if isinstance(layer, QgsVectorLayer):
                            collected.append((layer, parent_id))
                return collected

            vector_layers = collect_layers(project.layerTreeRoot())

            # Маппинг стилей линий/заливок на class-type
            def get_style_code(symbol_layer):
                if hasattr(symbol_layer, 'penStyle'):
                    pen = symbol_layer.penStyle()
                    if pen == 1: return 0  # Solid
                    if pen == 2: return 1  # Dash
                    if pen == 3: return 2  # DashDot (DotDash)
                    if pen == 4: return 7  # Dots (Dot)
                if hasattr(symbol_layer, 'brushStyle'):
                    brush = symbol_layer.brushStyle()
                    if brush == 1: return 0  # Solid
                    if brush == 5: return 5  # Horiz
                    if brush == 6: return 6  # Vert
                    if brush == 9: return 3  # BDiag
                    if brush == 10: return 4  # FDiag
                return 0  # Default Solid

            for idx, (vl, parent_id) in enumerate(vector_layers):
                renderer = vl.renderer()
                if not renderer:
                    continue
                symbol = renderer.symbol()
                if not symbol or symbol.symbolLayerCount() == 0:
                    continue
                symbol_layer = symbol.symbolLayer(0)

                shape = self._shape_detector(vl)
                if shape == 0:
                    continue

                cls = {
                    'id': vl.name(),
                    'objects': [],
                    'shape': shape,
                    'parent-id': parent_id,
                    'style': get_style_code(symbol_layer),
                    'layer': idx,
                    'width': 0.2,  # Default, override below
                    'min-mip': 0.0,
                    'max-mip': 0.0,
                    'line-color': 0,
                    'fill-color': 0,
                    'text-color': 0,
                    'attributes': {},  # Можно добавить метаданные слоя, напр. {'crs': vl.crs().authid()}
                }

                # Min/max mip из scale visibility (приближенно, mip ~ scale / const, но здесь default)
                if vl.hasScaleBasedVisibility():
                    cls['min-mip'] = vl.minimumScale() / 1000000.0  # Примерная конверсия
                    cls['max-mip'] = vl.maximumScale() / 1000000.0

                # Цвета и ширина
                line_color = self._qcolor_to_argb_int(symbol_layer.strokeColor()) if hasattr(symbol_layer,
                                                                                             'strokeColor') else self._qcolor_to_argb_int(
                    symbol.color())
                fill_color = self._qcolor_to_argb_int(symbol.color())
                text_color = 0  # TODO: Из лейблов, если нужно
                cls['line-color'] = line_color
                cls['fill-color'] = fill_color
                cls['text-color'] = text_color

                if shape == 1:
                    cls['width'] = float(symbol.size())
                elif shape == 2:
                    cls['width'] = float(symbol_layer.width()) if hasattr(symbol_layer, 'width') else 0.5
                elif shape == 3:
                    cls['width'] = float(symbol_layer.strokeWidth()) if hasattr(symbol_layer, 'strokeWidth') else 0.2

                # Объекты (features)
                for feature in vl.getFeatures():
                    geometry = feature.geometry()
                    attrs = {field.name(): feature[field.name()] for field in vl.fields()}
                    outers = []
                    inners = []

                    if shape == 1:  # Point or MultiPoint
                        points = geometry.asMultiPoint() if geometry.isMultipart() else [geometry.asPoint()]
                        outers = [[[p.y() * mul, p.x() * mul]] for p in points]

                    elif shape == 2:  # Line or MultiLine
                        lines = geometry.asMultiPolyline() if geometry.isMultipart() else [geometry.asPolyline()]
                        for line in lines:
                            if not line:
                                continue
                            first = line[0]
                            poly = [[first.y() * mul, first.x() * mul]]
                            for pt in line[1:]:
                                delta_lat = (pt.y() - first.y()) * mul
                                delta_lon = (pt.x() - first.x()) * mul
                                poly.append([delta_lat, delta_lon])
                            outers.append(poly)

                    elif shape == 3:  # Polygon or MultiPolygon
                        polys = geometry.asMultiPolygon() if geometry.isMultipart() else [geometry.asPolygon()]
                        for poly in polys:
                            if not poly:
                                continue
                            # Outer
                            outer_ring = poly[0]
                            if outer_ring:
                                first = outer_ring[0]
                                outer_poly = [[first.y() * mul, first.x() * mul]]
                                for pt in outer_ring[1:]:
                                    delta_lat = (pt.y() - first.y()) * mul
                                    delta_lon = (pt.x() - first.x()) * mul
                                    outer_poly.append([delta_lat, delta_lon])
                                outers.append(outer_poly)
                            # Inners
                            for inner_ring in poly[1:]:
                                if inner_ring:
                                    first = inner_ring[0]
                                    inner_poly = [[first.y() * mul, first.x() * mul]]
                                    for pt in inner_ring[1:]:
                                        delta_lat = (pt.y() - first.y()) * mul
                                        delta_lon = (pt.x() - first.x()) * mul
                                        inner_poly.append([delta_lat, delta_lon])
                                    inners.append(inner_poly)

                    cls['objects'].append([outers, inners, attrs])

                obj['classes'].append(cls)

            imx_path = self.exportFileQgsWidget.filePath()
            with open(imx_path, 'wb') as fp:
                dump(obj, fp, default=self.custom_encoder)

        finally:
            self.exportButton.setEnabled(True)
