# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IndyMapsConverterDialog
                                 A QGIS plugin
 This plugin imports/exports the QGIS project to the IndyMaps format (*.imx)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonid Kolesnichenko
        email                : xperience439@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from datetime import datetime

from PyQt5.QtCore import QMetaType
from PyQt5.QtGui import QColor
from cbor2 import load, dump
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis._core import QgsRenderContext

from qgis.core import (
    QgsProject, QgsWkbTypes, QgsLayerTreeGroup, QgsLayerTreeLayer,
    Qgis, QgsField, QgsCoordinateReferenceSystem, QgsRectangle,
    QgsReferencedRectangle, QgsPointXY, QgsGeometry, QgsVectorLayer,
    QgsFeature
)
from qgis.utils import iface

# Константы для типов геометрии
POINT_TYPE = 1
LINE_TYPE = 2
POLYGON_TYPE = 3

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'indy_maps_converter_dialog_base.ui'))


class IndyMapsConverterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super().__init__(parent)
        self.setupUi(self)

        self.importButton.clicked.connect(self.import_imx)
        self.exportButton.clicked.connect(self.export_imx)
        self.from_degs_mul = 10000000.0

        self.canvas = iface.mapCanvas()
        self.iface = iface

    def custom_encoder(self, encoder, value):
        """Custom encoder for unsupported types"""
        if isinstance(value, set):
            encoder.encode(list(value))
        elif isinstance(value, datetime):
            encoder.encode(value.isoformat())
        elif hasattr(value, '__dict__'):
            encoder.encode(value.__dict__)
        else:
            encoder.encode(str(value))

    def _decode_rgba(self, color_int):
        """Декодирование RGBA из целого числа"""
        return (
            (color_int >> 16) & 0xff,
            (color_int >> 8) & 0xff,
            color_int & 0xff,
            (color_int >> 24) & 0xff
        )

    def _process_borders(self, obj, crs):
        """Обработка границ проекта"""
        border = obj['borders'][0]
        settings = obj['settings']

        xs = [pt[1] / settings['from-degs-mul'] for pt in border]
        ys = [pt[0] / settings['from-degs-mul'] for pt in border]

        rectangle = QgsRectangle(min(xs), min(ys), max(xs), max(ys))
        referenced_extent = QgsReferencedRectangle(rectangle, crs)

        QgsProject.instance().viewSettings().setPresetFullExtent(referenced_extent)
        self.canvas.refresh()

    def _create_layer(self, cls, geometry_type, settings):
        """Создание векторного слоя с настройками символа"""
        layer = QgsVectorLayer(
            f"{geometry_type}?crs=EPSG:4326",
            cls['id'],
            "memory"
        )

        symbol = layer.renderer().symbol()

        if cls['shape'] == POINT_TYPE:
            symbol.setSizeUnit(Qgis.RenderUnit.Millimeters)
            rgba = self._decode_rgba(cls['fill-color'])
            symbol.setColor(QColor.fromRgb(*rgba))
            symbol.setSize(cls['width'])
        elif cls['shape'] == LINE_TYPE:
            symbol.setWidthUnit(Qgis.RenderUnit.Millimeters)
            rgba = self._decode_rgba(cls['line-color'])
            symbol.setColor(QColor.fromRgb(*rgba))
            symbol.setWidth(cls['width'])
        elif cls['shape'] == POLYGON_TYPE:
            fill_rgba = self._decode_rgba(cls['fill-color'])
            stroke_rgba = self._decode_rgba(cls['line-color'])
            symbol.setColor(QColor.fromRgb(*fill_rgba))
            symbol.symbolLayer(0).setStrokeWidth(cls['width'])
            symbol.symbolLayer(0).setStrokeColor(QColor.fromRgb(*stroke_rgba))

        return layer

    def _process_points(self, cls, settings, all_attributes):
        """Обработка точечных объектов"""
        features = []
        for obj_data in cls['objects']:
            outer_geom = obj_data[0][0][0]
            attribs = obj_data[-1]

            all_attributes.update(attribs.keys())

            qgs_point = QgsPointXY(
                outer_geom[1] / settings['from-degs-mul'],
                outer_geom[0] / settings['from-degs-mul']
            )

            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPointXY(qgs_point))
            feature.setAttributes(list(attribs.values()))
            features.append(feature)

        return features

    def _process_lines(self, cls, settings, all_attributes):
        """Обработка линейных объектов"""
        features = []
        for obj_data in cls['objects']:
            attribs = obj_data[-1]
            all_attributes.update(attribs.keys())

            outer_geom = obj_data[0]
            outer_starting_point = outer_geom[0][0]
            outer_geometry = []

            for x, y in outer_geom[0][1:]:
                x = (outer_starting_point[0] + x) / settings['from-degs-mul']
                y = (outer_starting_point[1] + y) / settings['from-degs-mul']
                outer_geometry.append(QgsPointXY(y, x))

            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPolylineXY(outer_geometry))
            feature.setAttributes(list(attribs.values()))
            features.append(feature)

        return features

    def _process_polygons(self, cls, settings, all_attributes):
        """Обработка полигональных объектов"""
        features = []
        for obj_data in cls['objects']:
            attribs = obj_data[-1]
            all_attributes.update(attribs.keys())

            outer_geometry = self._create_polygon(obj_data, settings)
            inner_geometry = self._create_polygon(obj_data, settings, inner=True)
            geometry = outer_geometry.difference(inner_geometry)
            feature = QgsFeature()
            feature.setGeometry(outer_geometry)
            feature.setAttributes(list(attribs.values()))
            features.append(feature)

        return features

    def _create_polygon(self, obj, settings, inner=False):
        """Создание полигона из данных объекта"""
        idx = 1 if inner else 0

        if inner and not obj[idx]:
            return QgsGeometry.fromWkt("POLYGON EMPTY")

        points = []
        geom = obj[idx]
        starting_point = geom[0][0]

        points.append(QgsPointXY(
            starting_point[1] / settings['from-degs-mul'],
            starting_point[0] / settings['from-degs-mul']
        ))

        for x, y in geom[0][1:]:
            x = (starting_point[0] + x) / settings['from-degs-mul']
            y = (starting_point[1] + y) / settings['from-degs-mul']
            points.append(QgsPointXY(y, x))

        return QgsGeometry.fromPolygonXY([points])

    def import_imx(self):
        """Импорт IMX файла (устойчив к отсутствующим/пустым borders)."""
        try:
            self.importButton.setEnabled(False)
            imx_path = self.inputFileQgsWidget.filePath()

            if not imx_path:
                raise ValueError("Не выбран файл для импорта")

            self.importProgressBar.setValue(0)

            from cbor2 import load
            with open(imx_path, 'rb') as fp:
                obj = load(fp)

            # CRS проекта для пресета экстента
            crs = QgsCoordinateReferenceSystem('EPSG:4326')

            # Настройки масштаба координат
            settings = obj.get('settings', {})
            mul = settings.get('from-degs-mul', self.from_degs_mul)

            # 1) Экстент проекта:
            #    - если borders непустой — используем существующую логику
            #    - иначе вычисляем из classes/objects
            def set_preset_extent_from_bounds(minx, miny, maxx, maxy):
                rect = QgsRectangle(minx, miny, maxx, maxy)
                ref_rect = QgsReferencedRectangle(rect, crs)
                QgsProject.instance().viewSettings().setPresetFullExtent(ref_rect)

            borders = obj.get('borders') or []
            if borders:
                # Старый путь, если границы заданы
                self._process_borders(obj, crs)
            else:
                # Вычислить экстент по объектам IMX
                minx = float('inf')
                miny = float('inf')
                maxx = float('-inf')
                maxy = float('-inf')

                def update_from_polygon(poly):
                    nonlocal minx, miny, maxx, maxy
                    if not poly:
                        return
                    # poly: [ [lat_abs, lon_abs], [dlat, dlon], ... ]
                    lat = poly[0][0]
                    lon = poly[0][1]
                    # абсолютная первая точка
                    x = lon / mul
                    y = lat / mul
                    if x < minx: minx = x
                    if x > maxx: maxx = x
                    if y < miny: miny = y
                    if y > maxy: maxy = y
                    # накапливаем относительные дельты
                    cur_lat = lat
                    cur_lon = lon
                    for dlat, dlon in poly[1:]:
                        cur_lat += dlat
                        cur_lon += dlon
                        x = cur_lon / mul
                        y = cur_lat / mul
                        if x < minx: minx = x
                        if x > maxx: maxx = x
                        if y < miny: miny = y
                        if y > maxy: maxy = y

                for cls in obj.get('classes', []):
                    for obj_data in cls.get('objects', []):
                        outers = obj_data[0] if len(obj_data) > 0 else []
                        inners = obj_data[1] if len(obj_data) > 1 else []
                        for poly in outers:
                            update_from_polygon(poly)
                        for poly in inners:
                            update_from_polygon(poly)

                # Если удалось вычислить экстент — задаём его как preset full extent
                if minx != float('inf') and miny != float('inf'):
                    set_preset_extent_from_bounds(minx, miny, maxx, maxy)
                # Иначе ничего не задаём: QGIS сможет вычислить максимальный экстент по слоям, если preset останется null

            layers_to_add = {}
            total_classes = len(obj.get('classes', [])) or 1

            for i, cls in enumerate(obj.get('classes', [])):
                self.importProgressLabel.setText(f"Обработка слоя: {cls['id']}")

                # Определяем тип геометрии
                if cls['shape'] == POINT_TYPE:
                    geometry_type = "Point"
                elif cls['shape'] == LINE_TYPE:
                    geometry_type = "LineString"
                elif cls['shape'] == POLYGON_TYPE:
                    geometry_type = "Polygon"
                else:
                    continue

                # Создаем слой
                layer = self._create_layer(cls, geometry_type, obj['settings'])
                all_attributes = set()

                # Обрабатываем объекты в зависимости от типа
                if cls['shape'] == POINT_TYPE:
                    features = self._process_points(cls, obj['settings'], all_attributes)
                elif cls['shape'] == LINE_TYPE:
                    features = self._process_lines(cls, obj['settings'], all_attributes)
                elif cls['shape'] == POLYGON_TYPE:
                    features = self._process_polygons(cls, obj['settings'], all_attributes)

                # Добавляем поля атрибутов
                if all_attributes:
                    layer.dataProvider().addAttributes([
                        QgsField(attr, QMetaType.Type.QString)
                        for attr in all_attributes
                    ])
                    layer.updateFields()
                    # Обновляем атрибуты для всех фич
                    for feature in features:
                        feature.setFields(layer.fields())

                # Добавляем объекты в слой
                if features:
                    layer.dataProvider().addFeatures(features)

                layers_to_add[cls['layer']] = layer
                self.importProgressBar.setValue(int((i + 1) / total_classes * 100))

            # Добавляем слои в проект в правильном порядке
            for layer_order in sorted(layers_to_add.keys()):
                QgsProject.instance().addMapLayer(layers_to_add[layer_order])

            self.canvas.refresh()
            self.importProgressBar.setValue(100)

        except Exception as e:
            raise e
        finally:
            self.importButton.setEnabled(True)

    def _shape_detector(self, vector_layer):
        """Определение типа геометрии слоя"""
        geom_type = vector_layer.geometryType()
        if geom_type == QgsWkbTypes.PointGeometry:
            return POINT_TYPE
        elif geom_type == QgsWkbTypes.LineGeometry:
            return LINE_TYPE
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return POLYGON_TYPE
        return None

    def get_vector_layers_in_order(self, node):
        """Получение векторных слоев в порядке их отображения в дереве слоев"""
        layers = []
        for child in node.children():
            if isinstance(child, QgsLayerTreeLayer):
                layer = child.layer()
                if isinstance(layer, QgsVectorLayer):
                    layers.append(layer)
            elif isinstance(child, QgsLayerTreeGroup):
                layers.extend(self.get_vector_layers_in_order(child))
        return layers

    def convert_to_ims_coord_format(self, x, y):
        """Конвертация координат в формат IMS"""
        return [int(y * self.from_degs_mul), int(x * self.from_degs_mul)]

    def substract_from_first_point(self, first_point, x, y):
        """Вычитание координат из первой точки"""
        return [
            int((first_point.y() - y) * self.from_degs_mul),
            int((first_point.x() - x) * self.from_degs_mul)
        ]

    def color_converter(self, color):
        """Конвертация цвета в целочисленный формат"""
        hex_clean = color.lstrip('#')
        argb_int = int(hex_clean, 16)

        # Если hex был #RRGGBB (6 digits, no alpha), add full opacity (alpha=255)
        if len(hex_clean) == 6:
            argb_int = (255 << 24) | argb_int
        return argb_int

    @staticmethod
    def _qcolor_to_argb_int(c: QColor) -> int:
        """Конвертирует QColor в ARGB uint (alpha << 24 | red << 16 | green << 8 | blue)."""
        return (c.alpha() << 24) | (c.red() << 16) | (c.green() << 8) | c.blue()

    def _legend_items(self, renderer):
        """
        Return a list of (key, label, symbol) for any renderer type.
        Falls back to a single default item if needed.
        """
        if not renderer:
            return []

        # Try to use legend items when available
        items = []
        if hasattr(renderer, "legendSymbolItems"):
            for it in renderer.legendSymbolItems():
                # QgsLegendSymbolItem has .key(), .label(), .symbol()
                items.append((it.key(), it.label(), it.symbol()))
            if items:
                return items

        # Fallbacks
        # 1) single symbol
        if hasattr(renderer, "symbol") and renderer.symbol():
            return [("default", "", renderer.symbol())]

        # 2) multiple symbols list
        try:
            symbols = renderer.symbols()
        except TypeError:
            symbols = renderer.symbols(QgsRenderContext())
        if symbols:
            return [(f"default-{i}", "", s) for i, s in enumerate(symbols)]

        return []

    def _extract_style(self, symbol, shape):
        """
        Derive width/line/fill colors from a symbol in a renderer-agnostic way.
        """
        line_color = self._qcolor_to_argb_int(symbol.color())
        fill_color = self._qcolor_to_argb_int(symbol.color())
        width = 0.2

        if symbol.symbolLayerCount() > 0:
            sl = symbol.symbolLayer(0)

            # Colors
            if hasattr(sl, "strokeColor"):
                line_color = self._qcolor_to_argb_int(sl.strokeColor())
            elif hasattr(sl, "color"):
                line_color = self._qcolor_to_argb_int(sl.color())

            if hasattr(sl, "fillColor"):
                fill_color = self._qcolor_to_argb_int(sl.fillColor())
            elif hasattr(sl, "color"):
                fill_color = self._qcolor_to_argb_int(sl.color())

            # Width/Size
            if shape == POINT_TYPE:
                if hasattr(symbol, "size"):
                    width = float(symbol.size())
            elif shape == LINE_TYPE:
                if hasattr(sl, "width"):
                    width = float(sl.width())
            elif shape == POLYGON_TYPE:
                if hasattr(sl, "strokeWidth"):
                    width = float(sl.strokeWidth())

        return width, line_color, fill_color

    def export_imx(self):
        # Lazy import для контекста рендера
        from qgis.core import QgsRenderContext

        self.exportButton.setEnabled(False)
        try:
            obj = {
                'settings': {
                    'min-mip': 0.0,
                    'max-mip': 50.0,
                    'compression-policy': 1,
                    'from-degs-mul': 10_000_000.0,
                },
                'borders': [],
                'classes': []
            }
            mul = obj['settings']['from-degs-mul']

            project = QgsProject.instance()

            # Экспорт границ из presetFullExtent как один полигон (как было)
            preset_extent = project.viewSettings().presetFullExtent()
            if not preset_extent.isNull():
                xmin = preset_extent.xMinimum()
                ymin = preset_extent.yMinimum()
                xmax = preset_extent.xMaximum()
                ymax = preset_extent.yMaximum()
                abs_first = [ymax * mul, xmin * mul]  # [lat_mul, lon_mul]
                polygon = [abs_first]
                polygon.append([0, (xmax - xmin) * mul])  # top-right
                polygon.append([(ymin - ymax) * mul, 0])  # bottom-right
                polygon.append([0, (xmin - xmax) * mul])  # bottom-left
                obj['borders'] = [polygon]

            # Рекурсивный проход по дереву слоев
            def collect_layers(node, parent_id=""):
                collected = []
                for child in node.children():
                    if isinstance(child, QgsLayerTreeGroup):
                        group_id = child.name() if child.name() else parent_id
                        collected.extend(collect_layers(child, group_id))
                    elif isinstance(child, QgsLayerTreeLayer):
                        layer = child.layer()
                        if isinstance(layer, QgsVectorLayer):
                            collected.append((layer, parent_id))
                return collected

            vector_layers = collect_layers(project.layerTreeRoot())

            # Маппинг стилей линий/заливок на class-type (как было)
            def get_style_code(symbol_layer):
                if hasattr(symbol_layer, 'penStyle'):
                    pen = symbol_layer.penStyle()
                    if pen == 1: return 0  # Solid
                    if pen == 2: return 1  # Dash
                    if pen == 3: return 2  # DashDot
                    if pen == 4: return 7  # Dots
                if hasattr(symbol_layer, 'brushStyle'):
                    brush = symbol_layer.brushStyle()
                    if brush == 1: return 0  # Solid
                    if brush == 5: return 5  # Horiz
                    if brush == 6: return 6  # Vert
                    if brush == 9: return 3  # BDiag
                    if brush == 10: return 4  # FDiag
                return 0  # Default Solid

            # Подготовим контекст рендера для вызовов symbolForFeature(...)
            ctx = QgsRenderContext.fromMapSettings(self.canvas.mapSettings())

            for idx, (vl, parent_id) in enumerate(vector_layers):
                renderer = vl.renderer()
                if not renderer:
                    continue

                shape = self._shape_detector(vl)
                if not shape:
                    continue

                cls = {
                    'id': vl.name(),
                    'objects': [],
                    'shape': shape,
                    'parent-id': parent_id,
                    'style': 0,
                    'layer': idx,
                    'width': 0.2,
                    'min-mip': 0.0,
                    'max-mip': 0.0,
                    'line-color': 0,
                    'fill-color': 0,
                    'text-color': 0,
                    'attributes': {},
                }

                # Min/max mip из видимости по масштабу (как было)
                if vl.hasScaleBasedVisibility():
                    cls['min-mip'] = vl.minimumScale() / 1_000_000.0
                    cls['max-mip'] = vl.maximumScale() / 1_000_000.0

                # Итерируем фичи, получая фактический символ через symbolForFeature(...)
                # symbolForFeature должен вызываться между startRender(...) и stopRender(...)
                renderer.startRender(ctx, vl.fields())
                try:
                    first_symbol_for_class = None

                    for feature in vl.getFeatures():
                        geometry = feature.geometry()
                        if not geometry or geometry.isEmpty():
                            continue

                        # Получаем символ для фичи; если рендерер возвращает несколько, берем первый
                        sym = renderer.symbolForFeature(feature, ctx)
                        if sym is None:
                            syms = renderer.symbolsForFeature(feature, ctx)
                            sym = syms[0] if syms else None
                        symbol_layer = sym.symbolLayer(0) if sym and sym.symbolLayerCount() > 0 else None

                        # Инициализируем стиль класса по первому встретившемуся символу
                        if sym and first_symbol_for_class is None:
                            first_symbol_for_class = sym
                            # Цвета
                            line_color = self._qcolor_to_argb_int(
                                symbol_layer.strokeColor()) if symbol_layer and hasattr(symbol_layer,
                                                                                        'strokeColor') else self._qcolor_to_argb_int(
                                sym.color())
                            fill_color = self._qcolor_to_argb_int(sym.color())
                            cls['line-color'] = line_color
                            cls['fill-color'] = fill_color
                            # Толщина/размер
                            if shape == POINT_TYPE:
                                cls['width'] = float(sym.size()) if hasattr(sym, 'size') else cls['width']
                            elif shape == LINE_TYPE:
                                if symbol_layer and hasattr(symbol_layer, 'width'):
                                    cls['width'] = float(symbol_layer.width())
                                elif hasattr(sym, 'width'):
                                    cls['width'] = float(sym.width())
                            elif shape == POLYGON_TYPE:
                                if symbol_layer and hasattr(symbol_layer, 'strokeWidth'):
                                    cls['width'] = float(symbol_layer.strokeWidth())
                            # Стиль штриха/заливки
                            if symbol_layer:
                                cls['style'] = get_style_code(symbol_layer)

                        # Атрибуты фичи
                        attrs = {field.name(): feature[field.name()] for field in vl.fields()}
                        outers = []
                        inners = []

                        # Геометрия -> формат IMX
                        if shape == POINT_TYPE:
                            pts = geometry.asMultiPoint() if geometry.isMultipart() else [geometry.asPoint()]
                            outers = [[[p.y() * mul, p.x() * mul]] for p in pts]

                        elif shape == LINE_TYPE:
                            lines = geometry.asMultiPolyline() if geometry.isMultipart() else [geometry.asPolyline()]
                            for line in lines:
                                if not line:
                                    continue
                                first = line[0]
                                poly = [[first.y() * mul, first.x() * mul]]
                                for pt in line[1:]:
                                    delta_lat = (pt.y() - first.y()) * mul
                                    delta_lon = (pt.x() - first.x()) * mul
                                    poly.append([delta_lat, delta_lon])
                                outers.append(poly)

                        elif shape == POLYGON_TYPE:
                            polys = geometry.asMultiPolygon() if geometry.isMultipart() else [geometry.asPolygon()]
                            for poly in polys:
                                if not poly:
                                    continue
                                # Внешнее кольцо
                                outer_ring = poly[0]
                                if outer_ring:
                                    first = outer_ring[0]
                                    outer_poly = [[first.y() * mul, first.x() * mul]]
                                    for pt in outer_ring[1:]:
                                        delta_lat = (pt.y() - first.y()) * mul
                                        delta_lon = (pt.x() - first.x()) * mul
                                        outer_poly.append([delta_lat, delta_lon])
                                    outers.append(outer_poly)
                                # Внутренние кольца
                                for inner_ring in poly[1:]:
                                    if inner_ring:
                                        first = inner_ring[0]
                                        inner_poly = [[first.y() * mul, first.x() * mul]]
                                        for pt in inner_ring[1:]:
                                            delta_lat = (pt.y() - first.y()) * mul
                                            delta_lon = (pt.x() - first.x()) * mul
                                            inner_poly.append([delta_lat, delta_lon])
                                        inners.append(inner_poly)

                        cls['objects'].append([outers, inners, attrs])
                finally:
                    renderer.stopRender(ctx)

                obj['classes'].append(cls)

            imx_path = self.exportFileQgsWidget.filePath()
            with open(imx_path, 'wb') as fp:
                dump(obj, fp, default=self.custom_encoder)

        finally:
            self.exportButton.setEnabled(True)
