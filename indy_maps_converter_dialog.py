# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IndyMapsConverterDialog
                                 A QGIS plugin
 This plugin imports/exports the QGIS project to the IndyMaps format (*.imx)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Leonid Kolesnichenko
        email                : xperience439@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from datetime import datetime

from PyQt5.QtCore import QMetaType
from PyQt5.QtGui import QColor
from cbor2 import load, dump
from cloudinit import settings
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.core import QgsProject, QgsWkbTypes, QgsLayerTreeGroup, QgsLayerTreeLayer, Qgis, QgsField, QgsCoordinateReferenceSystem, QgsRectangle, QgsReferencedRectangle, QgsPointXY, QgsGeometry, QgsFields, QgsVectorLayer, QgsFeature
from qgis.utils import iface

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'indy_maps_converter_dialog_base.ui'))


class IndyMapsConverterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(IndyMapsConverterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.importButton.clicked.connect(self.import_imx)
        self.exportButton.clicked.connect(self.export_imx)
        self.from_degs_mul = 10000000.0

        self.canvas = iface.mapCanvas()
        self.iface = iface

    def custom_encoder(self, encoder, value):
        """Custom encoder for unsupported types"""
        if isinstance(value, set):
            # Convert set to list
            encoder.encode(list(value))
        elif isinstance(value, datetime):
            # Convert datetime to ISO string
            encoder.encode(value.isoformat())
        elif hasattr(value, '__dict__'):
            # For custom objects, serialize their __dict__
            encoder.encode(value.__dict__)
        else:
            # Fallback: convert to string representation
            encoder.encode(str(value))


    def import_imx(self):
        self.importButton.setEnabled(False)
        imx_path = self.inputFileQgsWidget.filePath()

        self.importProgressBar.setValue(0)

        project = QgsProject.instance()
        crs = QgsCoordinateReferenceSystem('EPSG:4326')


        with open(imx_path, 'rb') as fp:
            obj = load(fp)
            border = obj['borders'][0]
            classes = obj['classes']
            settings = obj['settings']

            xs = [pt[1] / settings['from-degs-mul'] for pt in border]
            ys = [pt[0] / settings['from-degs-mul'] for pt in border]

            # Compute min and max for x and y
            xmin, xmax = min(xs), max(xs)
            ymin, ymax = min(ys), max(ys)

            rectangle = QgsRectangle(xmin, ymin, xmax, ymax)

            referenced_extent = QgsReferencedRectangle(rectangle, crs)

            project.viewSettings().setPresetFullExtent(referenced_extent)

            self.canvas.refresh()

            layers_to_add = {}

            for cls in classes:
                self.importProgressLabel.setText(f"Preprocessing layer: {cls['id']}")
                if cls['shape'] == 1: # Then it is point
                    layer_name = cls['id']
                    layer_order = cls['layer']
                    layer = QgsVectorLayer("Point?crs=EPSG:4326",
                                           layer_name,
                                           "memory")
                    symbol = layer.renderer().symbol()
                    symbol.setSizeUnit(Qgis.RenderUnit.Millimeters)  # switch to millimeters
                    rgba_fill_color = (cls['fill-color'] >> 16) & 0xff, (cls['fill-color'] >> 8) & 0xff, (cls['fill-color']) & 0xff, (cls['fill-color'] >> 24) & 0xff
                    symbol.setColor(QColor.fromRgb(*rgba_fill_color))
                    symbol.setSize(cls['width'])
                    for obj in cls['objects']:
                        outer_geom = obj[0][0][0]
                        attribs = obj[-1] # TODO: fix when correct imx will be sent


                        qgs_point = QgsPointXY(outer_geom[1] / settings['from-degs-mul'],
                                               outer_geom[0] /settings['from-degs-mul'])
                        outer_qgs_geometry = QgsGeometry.fromPointXY(qgs_point)

                        outer_feature = self._attribute_feature(attribs, layer)

                        outer_feature.setGeometry(outer_qgs_geometry)

                        layer.dataProvider().addFeature(outer_feature)

                    layers_to_add[layer_order] = layer
                if cls['shape'] == 2: # Then it is line
                    layer_name = cls['id']
                    layer_order = cls['layer']
                    layer = QgsVectorLayer("LineString?crs=EPSG:4326",
                                           layer_name,
                                           "memory")
                    symbol = layer.renderer().symbol()
                    symbol.setWidthUnit(Qgis.RenderUnit.Millimeters)  # switch to millimeters
                    rgba_fill_color = (cls['line-color'] >> 16) & 0xff, (cls['line-color'] >> 8) & 0xff, (cls['line-color']) & 0xff, (cls['line-color'] >> 24) & 0xff
                    symbol.setColor(QColor.fromRgb(*rgba_fill_color))
                    symbol.setWidth(cls['width'])

                    for obj in cls['objects']:
                        attribs = obj[-1]
                        outer_geometry = []
                        outer_geom = obj[0]
                        outer_starting_point = outer_geom[0][0]
                        for x, y in outer_geom[0][1:]:
                            x = (outer_starting_point[0] + x) / settings['from-degs-mul']
                            y = (outer_starting_point[1] + y) / settings['from-degs-mul']
                            outer_geometry.append(QgsPointXY(y, x))

                        outer_qgs_geometry = QgsGeometry.fromPolylineXY(outer_geometry)

                        outer_feature = self._attribute_feature(attribs, layer)

                        outer_feature.setGeometry(outer_qgs_geometry)

                        layer.dataProvider().addFeature(outer_feature)

                    layers_to_add[layer_order] = layer
                if cls['shape'] == 3: # Then it is multipolygon
                    layer_name = cls['id']
                    layer_order = cls['layer']
                    layer = QgsVectorLayer("Polygon?crs=EPSG:4326",
                                           layer_name,
                                           "memory")
                    symbol = layer.renderer().symbol()
                    rgba_fill_color = (cls['fill-color'] >> 16) & 0xff, (cls['fill-color'] >> 8) & 0xff, (cls['fill-color']) & 0xff, (cls['fill-color'] >> 24) & 0xff
                    rgba_stroke_color = (cls['line-color'] >> 16) & 0xff, (cls['line-color'] >> 8) & 0xff, (cls['line-color']) & 0xff, (cls['line-color'] >> 24) & 0xff
                    symbol.setColor(QColor.fromRgb(*rgba_fill_color))  # Fill color
                    symbol.symbolLayer(0).setStrokeWidth(cls['width'])  # in millimeters
                    symbol.symbolLayer(0).setStrokeColor(QColor.fromRgb(*rgba_stroke_color))

                    for obj in cls['objects']:
                        attribs = obj[-1]
                        outer_geometry = self.create_polygon(obj, settings)

                        outer_feature = self._attribute_feature(attribs, layer)

                        outer_feature.setGeometry(outer_geometry)

                        layer.dataProvider().addFeature(outer_feature)

                    layers_to_add[layer_order] = layer

        sorted_layers = dict(sorted(layers_to_add.items()))

        for layer in sorted_layers.values():
            self.importProgressBar.setValue(self.importProgressBar.value() + (100 // len(sorted_layers)))
            QgsProject.instance().addMapLayer(layer)
            self.canvas.refresh()

        self.importProgressBar.setValue(100)
        self.importButton.setEnabled(True)

    def create_polygon(self, obj, settings, inner=False):
        if inner:
            idx = 1
            if not obj[1]:
                return QgsGeometry.fromWkt("POLYGON EMPTY")
        else:
            idx = 0

        points = []
        geom = obj[idx]
        outer_starting_point = geom[idx][0]
        points.append(QgsPointXY(outer_starting_point[1] / settings['from-degs-mul'],
                                       outer_starting_point[0] / settings['from-degs-mul']))
        for x, y in geom[idx][1:]:
            x = (outer_starting_point[0] + x) / settings['from-degs-mul']
            y = (outer_starting_point[1] + y) / settings['from-degs-mul']
            points.append(QgsPointXY(y, x))

        return QgsGeometry.fromPolygonXY([points])

    def _attribute_feature(self, attributes, layer):
        for attribute in attributes.items():
            layer.dataProvider().addAttributes([
                QgsField(attribute[0], QMetaType.Type.QString)
            ])
        layer.updateFields()
        feature = QgsFeature(layer.fields())
        attr_list = [attributes.get(field.name()) for field in layer.fields()]
        feature.setAttributes(attr_list)
        return feature

    def _shape_detector(self, vector_layer):
        geom_type = vector_layer.geometryType()
        if geom_type == QgsWkbTypes.PointGeometry:
            return 1
        elif geom_type == QgsWkbTypes.LineGeometry:
            return 2
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return 3

    def get_vector_layers_in_order(self, node):
        layers = []
        for child in node.children():
            if isinstance(child, QgsLayerTreeLayer):
                layer = child.layer()
                if isinstance(layer, QgsVectorLayer):
                    layers.append(layer)
            elif isinstance(child, QgsLayerTreeGroup):
                layers.extend(self.get_vector_layers_in_order(child))
        return layers

    def convert_to_ims_coord_format(self, x, y):
        return [y * self.from_degs_mul, x * self.from_degs_mul]

    def substract_from_first_point(self, first_point, x, y):
        return [(first_point.y() * self.from_degs_mul) - y, (first_point.y() * self.from_degs_mul) - x]

    def export_imx(self):
        obj = {}
        obj['settings'] = {}
        obj['settings']['from-degs-mul'] = 10000000.0
        obj['settings']['compression-policy'] = 1
        obj['settings']['min-mip'] = 0.0
        obj['settings']['max-mip'] = 50.0
        obj['classes'] = []
        self.exportButton.setEnabled(False)
        # Access the current QGIS project instance
        project = QgsProject.instance()

        vector_layers = self.get_vector_layers_in_order(project.layerTreeRoot())

        for idx, vector_layer in enumerate(vector_layers):
            symbol = vector_layer.renderer().symbol()
            shape = self._shape_detector(vector_layer)
            features = vector_layer.getFeatures()

            width = 0
            line_color = 0
            fill_color = 0
            text_color = 0
            image = ''
            objects = []
            if shape == 1:
                objects = [[]]
                for feature in features:
                    geometry = feature.geometry()
                    attributes = feature.attributeMap()
                    pt = geometry.asPoint()
                    coord = self.convert_to_ims_coord_format(pt.x(), pt.y())
                    objects[0].append([coord, attributes])
            elif shape == 2:
                objects = [[]]
                for feature in features:
                    geometry = feature.geometry()
                    attributes = feature.attributeMap()
                    first_point = geometry.asPolyline()[0]
                    coords = [self.convert_to_ims_coord_format(first_point.x(), first_point.y())]
                    for pt in geometry.asPolyline()[1:]:
                        coords.append(
                            self.substract_from_first_point(first_point, pt.x(), pt.y())
                        )
                    objects[0].append([coords, attributes])
            elif shape == 3:
                objects = [[]]
                for feature in features:
                    geometry = feature.geometry()
                    attributes = feature.attributeMap()
                    first_point = geometry.asPolygon()[0][0]
                    coords = [[ (pt.x(), pt.y()) for pt in ring ] for ring in geometry.asPolygon()]
                    objects[0].append([coords, attributes])
            obj['classes'].append(
                {
                    'id': vector_layer.name(),
                    'objects': objects,
                    'shape': shape,
                    'layer': idx,
                    'width': width,
                    'line-color': line_color,
                    'fill-color': fill_color,
                    'text-color': text_color,
                    'image': image,
                    'attributes': {},
                }
            )


        preset_extent = project.viewSettings().presetFullExtent()

        if not preset_extent.isNull():
            xmin = preset_extent.xMinimum()
            ymin = preset_extent.yMinimum()
            xmax = preset_extent.xMaximum()
            ymax = preset_extent.yMaximum()


            obj['borders'] = [
                [ymax * obj['settings']['from-degs-mul'], xmax * obj['settings']['from-degs-mul']],
                [0, 0],
                [ymin * obj['settings']['from-degs-mul'], xmin * obj['settings']['from-degs-mul']],
                [ymin * obj['settings']['from-degs-mul'], xmin * obj['settings']['from-degs-mul']]
            ]

        imx_path = self.exportFileQgsWidget.filePath()

        with open(imx_path, 'wb') as fp:
            dump(obj, fp, default=self.custom_encoder)

        self.exportButton.setEnabled(True)